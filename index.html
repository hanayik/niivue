<!DOCTYPE html>
<html lang="en">
<head>
    <title>MRIcroGL for Web</title>
    <link rel="shortcut icon" href="data:image/x-icon;," type="image/x-icon">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        html,
        body {
            padding: 0;
            margin: 0;
            height: 100%;
            width: 100%;
            background: #808080;
        }

        ul {
            list-style-type: none;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #333;
        }

        li {
            float: left;
        }

        li a,
        .dropbtn {
            /* menu header */
            display: inline-block;
            color: white;
            text-align: center;
            padding: 14px 16px;
            text-decoration: none;
        }

        li a:hover,
        .dropdown:hover .dropbtn {
            background-color: #44ABDA;
        }

        li.dropdown {
            display: inline-block;
            font-family: Arial, Helvetica, sans-serif;
        }

        .dropdown-content {
            font-family: Arial, Helvetica, sans-serif;
            display: none;
            position: absolute;
            background-color: #f9f9f9;
            min-width: 160px;
            box-shadow: 0px 8px 16px 0px rgba(0, 0, 0, 0.2);
            z-index: 1;
        }

        .dropdown-content a {
            /* menu items */
            color: black;
            padding: 12px 16px;
            text-decoration: none;
            display: block;
            text-align: left;
        }

        .dropdown-content a:hover {
            background-color: #f1f1f1
        }

        .dropdown:hover .dropdown-content {
            display: block;
        }

        .divider,
        .linker,
        .dropdown-item-checked,
        .overlay {
            border-top: 1px solid grey;
        }

    	canvas {
			display: block;  /* prevents scrollbar */
			border: 0;
			width: 100vw;
			height: 90vh;
			max-width:100%;
			max-height:100%;
			overflow-x:hidden;
			overflow-y:hidden;
			top: 0;
			left: 0;
			margin: 0 auto;
   		}

   		<!--.dropdown-item-checked::before {
		  position: absolute;
		  left: .2rem;
		  content: 'âœ“';
		  font-weight: 600;
		}-->
    </style>
</head>

<body>
    <div id="menu-container">
        <input id="file-input" type="file" name="name" style="display: none;" />
        <ul>
            <li class="dropdown">
                <a href="javascript:void(0)" class="dropbtn" id="FileMenu">File</a>
                <div class="dropdown-content">
                    <a class="viewBtn" id="Open">Open</a>
                    <a class="viewBtn" id="SaveBitmap">Screen Shot</a>
                    <a class="linker" href="https://github.com/neurolabusc/niivue">About</a>
                </div>
            </li>
            <li class="dropdown">
                <a href="javascript:void(0)" class="dropbtn" id="ViewMenu">View</a>
                <div class="dropdown-content">
                    <a class="viewBtn" id="L">Left</a>
                    <a class="viewBtn" id="R">Right</a>
                    <a class="viewBtn" id="P">Posterior</a>
                    <a class="viewBtn" id="A">Anterior</a>
                    <a class="viewBtn" id="I">Inferior</a>
                    <a class="viewBtn" id="S">Superior</a>
                </div>
            </li>
            <li class="dropdown">
                <a href="javascript:void(0)" class="dropbtn">Color</a>
                <div class="dropdown-content">
                    <a class="viewBtn" id="!Gray">Gray</a>
                    <a class="viewBtn" id="!Plasma">Plasma</a>
                    <a class="viewBtn" id="!Viridis">Viridis</a>
                    <a class="viewBtn" id="!Inferno">Inferno</a>
                    <!-- <a class="viewBtn dropdown-item-checked" id="^Lighting">Lighting</a>  -->
                    <a class="divider" id="BackColor">Background Color</a>
                    <a class="viewBtn" id="ChangeContrast">Adjust brightness and contrast</a>
                    <a class="viewBtn" id="OpacityInc">Harder Edges</a>
                    <a class="viewBtn" id="OpacityDec">Softer Edges</a>
                </div>
            </li>
            <li class="dropdown">
                <a href="javascript:void(0)" class="dropbtn">Shader</a>
                <div class="dropdown-content">
                    <a class="viewBtn" id="^Standard">Volume Only</a>
                    <a class="viewBtn" id="^Lighting">Lighting</a>
                    <a class="viewBtn" id="^MIP">Maximum Intensity</a>
                    <a class="viewBtn" id="^Gradients">Gradients</a>
                    <a class="viewBtn" id="^MatCap">MatCap</a>
                    <a class="viewBtn" id="^Slices">Slices</a>
                </div>
            </li>
            <li class="dropdown">
                <a href="javascript:void(0)" class="dropbtn">MatCap</a>
                <div class="dropdown-content">
                    <a class="viewBtn" id="#0">White</a>
                    <a class="viewBtn" id="#1">Clay</a>
                    <a class="viewBtn" id="#2">Gold</a>
                    <a class="viewBtn" id="#3">Red</a>
                    <a class="viewBtn" id="#4">Cortex</a>
                </div>
            </li>
            <li class="dropdown">
                <a href="javascript:void(0)" class="dropbtn">Examples</a>
                <div class="dropdown-content">
                    <a class="viewBtn" id="_spm152.nii.gz">spm</a>
                    <a class="viewBtn" id="_Chris_MRA.nii.gz">MRA</a>
                    <a class="viewBtn" id="_zChris_T1.nii.gz">T1</a>
                </div>
            </li>
        </ul>
    </div>
    <div id="gl-container" ondrop="drop(event)" ondragover="allowDrop(event)">
    	<canvas id="glcanvas"></canvas>
    </div>
</body>
<script src="nifti/nifti-reader.js"></script>
<script src="volume/gl-matrix-min.js"></script>
<script src="volume/webgl-util.js"></script>
<script src="volume/shader-srcs.js"></script>
<script src="volume/FileSaver.js"></script>
<script>
//https://stackoverflow.com/questions/21286887/adding-check-marks-to-bootstrap-button-drop-down-items
var takeScreenShot = false;
var is2D = false;
var cubeStrip = [0,1,0, 1,1,0, 0,1,1, 1,1,1, 1,0,1, 1,1,0, 1,0,0, 0,1,0, 0,0,0, 0,1,1, 0,0,1, 1,0,1, 0,0,0, 1,0,0];
var mouseX = null;
var mouseY = null;
var container = null;
var isBlackBackColor = true;
var gl = null;
var isDrawOnDemand = true;
var canvas = null;
var shader = null;
var sliceShader = null;
var lineShader = null;
var blurShader = null;
var sobelShader = null;
var volumeTexture = null;
var gradientTexture = null;
var matcapTexture = null;
var colormapTexture = null;
var proj = null;
var vao = null;
var vbo = null;
var camera = null;
var projView = null;
var newVolumeUpload = true;
var targetFrameTime = 32;
var samplingRate = 1.0;
var crosshairWidth = 0.005;
var crosshairColor =  [1, 0, 0, 1];
var WIDTH = 320;
var HEIGHT = 320;
var longestAxis =  1.0;
var volScale = [1, 1, 1];
var xAR = 1.0
var yAR = 1.0
var sagitalRect = [0, 0, 0, 0]
var coronalRect = [0, 0, 0, 0]
var axialRect = [0, 0, 0 , 0]
canvas = document.getElementById("glcanvas");
var cRect = canvas.getBoundingClientRect();
var clickNdrag = function (e) {
	var cRect = canvas.getBoundingClientRect();        // Gets CSS pos, and width/height
	/* mouseX = e.clientX */
	/* mouseY = e.clientY */
	var shiftPressed = e.shiftKey
	if (shiftPressed) {
		mouseX = Math.round(e.clientX - cRect.left);  // Subtract the 'left' of the canvas 
		mouseY = Math.round(e.clientY - cRect.top);   // from the X/Y positions to make  
		//console.log("mouse", mouseX, mouseY)
		glDraw();
	}	
}
canvas.addEventListener("mousemove", clickNdrag)

var hdr;
var img;
var colorName = "";
var colorOpacity = 2;
const center = vec3.set(vec3.create(), 0.5, 0.5, 0.5);
var openDialog = document.createElement('input');
openDialog.type = 'file';
openDialog.onchange = e => {
	selectVolume(e.target.files[0], false);
}
document.addEventListener("keydown", function(evt) {
	if (evt.key == "z")  adjustOpacity(0.9);
	if (evt.key == "a") adjustOpacity(1.1);
	if (evt.key == "w") adjustQuality(1.1);
	if (evt.key == "q")  adjustQuality(0.9);
});
if (isDrawOnDemand)
	document.addEventListener('cameraRedraw', e => glDraw() );

var selectJpeg = function(jpegName) {
  var matCapImage = null;
  matCapImage = new Image();
  //console.log('loading ', jpegName);
  matCapImage.src = jpegName;  // MUST BE SAME DOMAIN!!!
  matCapImage.onload = function() {
  	//console.log('matcap resolution ', matCapImage.width, '<<<', matCapImage.height);
	if (matcapTexture !== null)
	gl.deleteTexture(matcapTexture); //release ');
		matcapTexture = gl.createTexture();
	gl.activeTexture(gl.TEXTURE3);
	gl.bindTexture(gl.TEXTURE_2D, matcapTexture);
	// Set the parameters so we can render any size image.
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	// Upload the image into the texture.
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, matCapImage);
  }
} // selectJpeg()

var selectColormap = function(lutName) {
    var lut = makeLut([0, 255], [0, 255], [0,255], [0,128],[0,255]); //gray
    if (lutName === "Plasma")
		lut = makeLut([13, 156, 237, 240],[8, 23, 121, 249],[135, 158, 83, 33],[0, 56, 80, 88], [0, 64, 192, 255]); //plasma
	if (lutName === "Viridis")
		lut = makeLut([68,49,53,253],[1,104,183,231],[84,142,121,37],[0,56,80,88],[0,65,192,255]);//viridis
	if (lutName === "Inferno")
		lut = makeLut([0,120,237,240],[0,28,105,249],[4,109,37,33],[0,56,80,88],[0,64,192,255]);//inferno
	colorName = lutName;
	if (colormapTexture !== null)
		gl.deleteTexture(colormapTexture); //release colormap');
	colormapTexture = gl.createTexture();
	gl.activeTexture(gl.TEXTURE1);
	gl.bindTexture(gl.TEXTURE_2D, colormapTexture);
	gl.texStorage2D(gl.TEXTURE_2D, 1, gl.RGBA8, 256, 1);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_R, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, 256, 1,gl.RGBA, gl.UNSIGNED_BYTE, lut);
} // selectColormap()

function adjustQuality(scale) {
	samplingRate = samplingRate * scale;
	samplingRate = Math.min(samplingRate, 10.0);
	samplingRate = Math.max(samplingRate, 0.7);
	gl.uniform1f(shader.uniforms["dt_scale"], samplingRate);
	console.log('quality ', samplingRate);
	if (isDrawOnDemand) glDraw();
} // adjustQuality()

function adjustOpacity(scale) {
	colorOpacity = colorOpacity * scale;
	colorOpacity = Math.min(colorOpacity, 10.0);
	colorOpacity = Math.max(colorOpacity, 0.1);
	selectColormap(colorName);
	console.log('opacity ', colorOpacity);
	if (isDrawOnDemand) glDraw();
} // adjustOpacity()

var loadVolume = function(url, isURL, onload) {
	if (!isURL) {
		var reader = new FileReader();
        	reader.readAsArrayBuffer(url);
            reader.addEventListener('load', function(event) {
            	console.log(event.target.result);
            	//loadGeometryCore(object, isOverlay);
            	var hdr = nifti.readHeader(event.target.result);
				var img;
				if  (nifti.isCompressed(event.target.result)) {
					img = nifti.readImage(hdr, nifti.decompress(event.target.result));
				} else
					img = nifti.readImage(hdr, event.target.result);
				//img = new Uint8Array(img);
				onload(url, hdr, img);

            });
        return;
	}
	var req = new XMLHttpRequest();
	req.open("GET", url, true);
	req.responseType = "arraybuffer";
	req.onprogress = function(evt) {
		//loadingProgressBar.setAttribute("style", "width: " + percent.toFixed(2) + "%");
	};
	req.onerror = function(evt) {
		console.log = "Error Loading Volume";
	};
	req.onload = function(evt) {
		var dataBuffer = req.response;
		if (dataBuffer) {
			var hdr = nifti.readHeader(dataBuffer);
			var img;
			if  (nifti.isCompressed(dataBuffer)) {
				img = nifti.readImage(hdr, nifti.decompress(dataBuffer));
			} else
				img = nifti.readImage(hdr, dataBuffer);
			//img = new Uint8Array(img);
			onload(url, hdr, img);
		} else {
			alert("Unable to load buffer properly from volume?");
			console.log("no buffer?");
		}
	};
	req.send();
} // loadVolume()

function bindBlankGL() {
	let texR = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_3D, texR);
	gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_R, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	gl.pixelStorei( gl.UNPACK_ALIGNMENT, 1 )
	gl.texStorage3D(gl.TEXTURE_3D, 1, gl.RGBA8, hdr.dims[1], hdr.dims[2], hdr.dims[3]);
	return texR;
} // bindBlankGL()

function gradientGL() {
	var faceStrip = [0,0,0, 0,1,0, 1,0,0, 1,1,0];
	var vao2 = gl.createVertexArray();
	gl.bindVertexArray(vao2);
	vbo2 = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, vbo2);
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(faceStrip), gl.STATIC_DRAW);
	gl.enableVertexAttribArray(0);
	gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
	var fb = gl.createFramebuffer();
	gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
	gl.disable(gl.CULL_FACE);
	gl.viewport(0, 0, hdr.dims[1], hdr.dims[2]);
	gl.disable(gl.BLEND);
 	tempTex3D = bindBlankGL();
	blurShader.use();
	gl.activeTexture(gl.TEXTURE1);
	gl.bindTexture(gl.TEXTURE_3D, tex);
	gl.uniform1i(blurShader.uniforms["intensityVol"], 1);
	gl.uniform1f(blurShader.uniforms["dX"], 0.7/ hdr.dims[1]);
	gl.uniform1f(blurShader.uniforms["dY"], 0.7/ hdr.dims[2]);
	gl.uniform1f(blurShader.uniforms["dZ"], 0.7/ hdr.dims[3]);
	gl.bindVertexArray(vao2);
	for (i = 0; i < (hdr.dims[3]-1); i++) {
		var coordZ = 1/hdr.dims[3] * (i + 0.5);
    	gl.uniform1f(blurShader.uniforms["coordZ"], coordZ);
    	gl.framebufferTextureLayer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, tempTex3D, 0, i);
    	gl.clear(gl.DEPTH_BUFFER_BIT);
    	gl.drawArrays(gl.TRIANGLE_STRIP, 0, faceStrip.length / 3);
	}
	sobelShader.use();
	gl.activeTexture(gl.TEXTURE1);
	gl.bindTexture(gl.TEXTURE_3D, tempTex3D);//input texture
	gl.uniform1i(sobelShader.uniforms["intensityVol"], 1);
	gl.uniform1f(sobelShader.uniforms["dX"], 0.7/ hdr.dims[1]);
	gl.uniform1f(sobelShader.uniforms["dY"], 0.7/ hdr.dims[2]);
	gl.uniform1f(sobelShader.uniforms["dZ"], 0.7/ hdr.dims[3]);
	gl.uniform1f(sobelShader.uniforms["coordZ"], 0.5);
	gl.bindVertexArray(vao2);
	gl.activeTexture(gl.TEXTURE0);
    if (gradientTexture !== null) gl.deleteTexture(gradientTexture);
	gradientTexture	= bindBlankGL();
	for (i = 0; i < (hdr.dims[3]-1); i++) {
		var coordZ = 1/hdr.dims[3] * (i + 0.5);
    	gl.uniform1f(sobelShader.uniforms["coordZ"], coordZ);
    	//console.log(coordZ);
    	gl.framebufferTextureLayer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gradientTexture, 0, i);
    	gl.clear(gl.DEPTH_BUFFER_BIT);
    	gl.drawArrays(gl.TRIANGLE_STRIP, 0, faceStrip.length / 3);
	}
	gl.deleteFramebuffer(fb);
	gl.deleteTexture(tempTex3D);
	//return to volume rendering shader
	shader.use();
	gl.bindVertexArray(vao);
	gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_3D, volumeTexture);
	gl.activeTexture(gl.TEXTURE2);
	gl.bindTexture(gl.TEXTURE_3D, gradientTexture);
	gl.activeTexture(gl.TEXTURE3);
	gl.bindTexture(gl.TEXTURE_2D, matcapTexture); //"matcap"
	gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
} // gradientGL()

/*function reportMat(m){
	console.log("m = [%.2f %.2f %.2f %.2f; %.2f %.2f %.2f %.2f; %.2f %.2f %.2f %.2f; %.2f %.2f %.2f %.2f]",
		m[0],m[1],m[2],m[3],
		m[4],m[5],m[6],m[7],
		m[8],m[9],m[10],m[11],
		m[12],m[13],m[14],m[15],
		);
}*/

var axSlice = 0.5
var corSlice = 0.5
var sagSlice = 0.5
var isInRect = function(x,y,rect) {
	var isin = x>rect[0] && x < rect[2]+rect[0] && y > rect[1] && y < rect[3]+rect[1]
	/* console.log(rect) */
	/* console.log(isin) */
	return isin
}

var mydraw = function() {
	canvas.style.backgroundColor = "black"
	/* gl.viewport(0, 0, gl.canvas.width, gl.canvas.height); */
	//WIDTH = canvas.clientWidth;
  	//HEIGHT = canvas.clientHeight;//menuHeight;
	xAR = HEIGHT/WIDTH;
	yAR = 1.0;
	if (xAR > 1.0) {
		yAR = WIDTH/HEIGHT;
		xAR =  1.0;
	} 
	//Draw Axial width=x, height=y
	//lower left quadrant (LTRB= -1,-1,0,0) is axial
	sliceShader.use();
	gl.uniform1i(sliceShader.uniforms["axCorSag"], 0);
	gl.uniform1f(sliceShader.uniforms["slice"], axSlice);
	var w = volScale[0]*xAR;
	var h = volScale[1]*yAR; 
	axialRect = [-w, -h, w, h]
	gl.uniform4f(sliceShader.uniforms["leftBottomWidthHeight"], -w, -h, w, h);
	//gl.uniform4f(sliceShader.uniforms["leftBottomWidthHeight"], 1-ys, -1+ys, xs, ys); 	
	gl.drawArrays(gl.TRIANGLE_STRIP, 5, 4);
	//draw crosshairs
	lineShader.use();
	gl.uniform4f(lineShader.uniforms["leftBottomWidthHeight"], -w, -h+(corSlice* h)-crosshairWidth, w, crosshairWidth);
	gl.uniform4fv(lineShader.uniforms["lineColor"], crosshairColor);
	gl.drawArrays(gl.TRIANGLE_STRIP, 5, 4);
	gl.uniform4f(lineShader.uniforms["leftBottomWidthHeight"], -w+(sagSlice* w)-crosshairWidth, -h, crosshairWidth, h);
	gl.uniform4fv(lineShader.uniforms["lineColor"], crosshairColor);
	gl.drawArrays(gl.TRIANGLE_STRIP, 5, 4);
	//draw coronal  width=x, height=z
	// upper left quadrant
	sliceShader.use();
	gl.uniform1i(sliceShader.uniforms["axCorSag"], 1);
	gl.uniform1f(sliceShader.uniforms["slice"], corSlice);
	w = volScale[0]*xAR;
	h = volScale[2]*yAR; 
	coronalRect = [-w, 0, w, h]
	gl.uniform4f(sliceShader.uniforms["leftBottomWidthHeight"], -w, 0, w, h);
	gl.drawArrays(gl.TRIANGLE_STRIP, 5, 4);
	//draw crosshairs
	lineShader.use();
	gl.uniform4f(lineShader.uniforms["leftBottomWidthHeight"], -w, (axSlice* h)-crosshairWidth, w, crosshairWidth);
	gl.uniform4fv(lineShader.uniforms["lineColor"], crosshairColor);
	gl.drawArrays(gl.TRIANGLE_STRIP, 5, 4);
	gl.uniform4f(lineShader.uniforms["leftBottomWidthHeight"], -w+(sagSlice* w)-crosshairWidth, 0, crosshairWidth, h);
	gl.uniform4fv(lineShader.uniforms["lineColor"], crosshairColor);
	gl.drawArrays(gl.TRIANGLE_STRIP, 5, 4);
	//draw sagital width=y, height=z
	//  upper right quadrant
	sliceShader.use();
	w = volScale[1]*xAR;
	h = volScale[2]*yAR; 
	sagitalRect = [0, 0, w, h]
	gl.uniform1i(sliceShader.uniforms["axCorSag"], 2);
	gl.uniform1f(sliceShader.uniforms["slice"], sagSlice);
	gl.uniform4f(sliceShader.uniforms["leftBottomWidthHeight"], 0, 0, w, h); 
	gl.drawArrays(gl.TRIANGLE_STRIP, 5, 4);
	//draw crosshairs
	lineShader.use();
	gl.uniform4f(lineShader.uniforms["leftBottomWidthHeight"], 0, (axSlice* h)-crosshairWidth, w, crosshairWidth);
	gl.uniform4fv(lineShader.uniforms["lineColor"], crosshairColor);
	gl.drawArrays(gl.TRIANGLE_STRIP, 5, 4);
	gl.uniform4f(lineShader.uniforms["leftBottomWidthHeight"], (corSlice* w)-crosshairWidth, 0, crosshairWidth, h);
	gl.uniform4fv(lineShader.uniforms["lineColor"], crosshairColor);
	gl.drawArrays(gl.TRIANGLE_STRIP, 5, 4);
}

function glDraw() {
	gl.clearColor(0.0, 0.0, 0.0, 0.0);
	gl.clear(gl.COLOR_BUFFER_BIT);

	if (is2D) { //show 2D slices not rendering
		hWIDTH = Math.round(WIDTH/2) // half width
		hHEIGHT = Math.round(HEIGHT/2) // half height
		var clipX = mouseX / gl.canvas.clientWidth  * 2 - 1;    
		var clipY = mouseY / gl.canvas.clientHeight * -2 + 1;
		/* console.log(clipX, clipY) */
		if (isInRect(clipX, clipY, axialRect)) {
			sagSlice = 1 - clipX / axialRect[2]+axialRect[1]//(mouseX-hWIDTH)/hWIDTH
			//leftBottomWidthHeight
			//  0    1    2    3
			// THIS WORKS (ONLY TESTING AXIAL FOR NOW)
			corSlice = 1 - clipY / axialRect[1] //1-mouseY/hHEIGHT
			console.log(corSlice)
		} else if (isInRect(clipX, clipY, coronalRect)) {
			/* sagSlice = mouseX/hWIDTH */
			/* axSlice = 1-(mouseY-hHEIGHT)/hHEIGHT */
		} else if (isInRect(clipX, clipY, sagitalRect)) {
			/* corSlice = mouseX/hWIDTH */
			/* axSlice = 1-mouseY/hHEIGHT */
		}
		mydraw()
		
		
	} else {
		sliceShader.use();
		gl.uniform1f(shader.uniforms["dt_scale"], samplingRate);
		projView = mat4.mul(projView, proj, camera.camera);
		gl.uniformMatrix4fv(shader.uniforms["normal_matrix"], false, camera.camera);
		gl.uniformMatrix4fv(shader.uniforms["proj_view"], false, projView);
		var eye = camera.eyePos();
		gl.uniform3fv(shader.uniforms["eye_pos"], eye);
		//Lighting
		//"Head-light" with light at camera location:
		//gl.uniform3fv(shader.uniforms["light_pos"], eye);
		//we will place a light directly above the camera, mixing headlight with top light
		var mx = Math.max( Math.abs(...eye) );
		up = camera.upDir();
		var light = eye;
		light[0] = eye[0] + up[0] * mx;
		light[1] = eye[1] + up[1] * mx;
		light[2] = eye[2] + up[2] * mx;
		gl.uniform3fv(shader.uniforms["light_pos"], light);
		//draw cube
		
		gl.drawArrays(gl.TRIANGLE_STRIP, 0, cubeStrip.length / 3);
	
	}
	// Wait for rendering to actually finish
	gl.finish();
	if (takeScreenShot) {
		takeScreenShot = false;
		canvas.toBlob(function(b) { saveAs(b, "screen.png"); }, "image/png");
	}
} // glDraw()

function updateVolume() { //load volume or change contrast
	//convert data to 8-bit image
	vox = hdr.dims[1] * hdr.dims[2] * hdr.dims[3];
	img8 = new Uint8Array(vox);
	if (hdr.datatypeCode === 2) //data already uint8
		imgRaw = new Uint8Array(img);
	else if (hdr.datatypeCode === 4)
		var imgRaw = new Int16Array(img);
	else if (hdr.datatypeCode === 16)
		var imgRaw = new Float32Array(img);
	else if (hdr.datatypeCode === 512)
		var imgRaw = new Uint16Array(img);
	mn = hdr.cal_min;
	mx = hdr.cal_max;
	var scale = 1;
	if (mx > mn) scale = 255 / (mx-mn);
	for (i = 0; i < (vox-1); i++) {
		v = imgRaw[i];
		v = (v * hdr.scl_slope) + hdr.scl_inter;
		if (v < mn)
			img8[i] = 0;
		else if (v > mx)
			img8[i] = 255;
		else
			img8[i] = (v-mn) * scale;
	}
	tex = gl.createTexture();
	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture(gl.TEXTURE_3D, tex);
	gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_R, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	gl.pixelStorei( gl.UNPACK_ALIGNMENT, 1 )
	gl.texStorage3D(gl.TEXTURE_3D, 1, gl.R8, hdr.dims[1], hdr.dims[2], hdr.dims[3]);
	gl.texSubImage3D(gl.TEXTURE_3D, 0, 0, 0, 0,hdr.dims[1], hdr.dims[2], hdr.dims[3],gl.RED, gl.UNSIGNED_BYTE, img8);
	var dims = [1.0, hdr.dims[1]*hdr.pixDims[1], hdr.dims[2]*hdr.pixDims[2],  hdr.dims[3]*hdr.pixDims[3]];
	//var dims = [1.0, hdr.dims[1]*hdr.pixdim[1], hdr.dims[2]*hdr.pixdim[2], hdr.dims[3]*hdr.pixdim[3]];
	longestAxis = Math.max(dims[1], Math.max(dims[2], dims[3]));
	volScale = [dims[1] / longestAxis, dims[2] / longestAxis, dims[3] / longestAxis];
	gl.uniform3iv(shader.uniforms["volume_dims"], [hdr.dims[1],hdr.dims[2],hdr.dims[3]]);
	gl.uniform3fv(shader.uniforms["volume_scale"], volScale);
	newVolumeUpload = true;
	//gradientGL();
	if (!volumeTexture) {
		volumeTexture = tex;
		if (isDrawOnDemand)
			;//glDraw();
		else {
			setInterval(function() {
				// Save them some battery if they're not viewing the tab
				if (document.hidden) {
					return;
				}
				var startTime = new Date();
				// Reset the sampling rate and camera for new volumes
				if (newVolumeUpload) {
					onWindowResize();
					samplingRate = 1.0;
					gl.uniform1f(shader.uniforms["dt_scale"], samplingRate);
				}
				glDraw();
				var endTime = new Date();
				var renderTime = endTime - startTime;
				var targetSamplingRate = renderTime / targetFrameTime;
				if (takeScreenShot) {
					takeScreenShot = false;
					canvas.toBlob(function(b) { saveAs(b, "screen.png"); }, "image/png");
				}
				// If we're dropping frames, decrease the sampling rate
				if (!newVolumeUpload && targetSamplingRate > samplingRate) {
					samplingRate = 0.8 * samplingRate + 0.2 * targetSamplingRate;
					gl.uniform1f(shader.uniforms["dt_scale"], samplingRate);
				}
				newVolumeUpload = false;
				startTime = endTime;
			}, targetFrameTime);
		}
	} else {
		gl.deleteTexture(volumeTexture);
		volumeTexture = tex;
		if (isDrawOnDemand) glDraw();
	}
	gradientGL();
	glDraw();
} // updateVolume()

var selectVolume = function(url, isURL = true) {
	loadVolume(url, isURL, function(file, xhdr, ximg) {
		hdr = xhdr;
		img = ximg;
		//determine range
		var imgRaw;
		if (hdr.datatypeCode === 2) //data already uint8
			imgRaw = new Uint8Array(img);
		else if (hdr.datatypeCode === 4)  //Int16
			imgRaw = new Int16Array(img);
		else if (hdr.datatypeCode === 16)  //Float32
			imgRaw = new Float32Array(img);
		else if (hdr.datatypeCode === 512) //UInt16
			imgRaw = new Uint16Array(img);
		else {
			alert('Unsupported data type');
			console.log("Unsupported data type %d", hdr.datatypeCode);
			var e = new Error('Unsupported data type', hdr.datatypeCode);
			throw e;
		}
		var vox = imgRaw.length;
		var mn = Infinity;
		var mx = -Infinity;
		for (i = 0; i < (vox-1); i++) {
			if (!isFinite(imgRaw[i])) continue;
			if (imgRaw[i] < mn) mn = imgRaw[i];
			if (imgRaw[i] > mx) mx = imgRaw[i];
		}
		//calibrate intensity
		if ((isFinite(hdr.scl_slope)) && (isFinite(hdr.scl_inter)) && (hdr.scl_slope !== 0.0 )) {
			//console.log(">> mn %f mx %f %f %f", mn, mx, hdr.scl_slope, hdr.scl_inter);
			mn = (mn * hdr.scl_slope) + hdr.scl_inter;
			mx = (mx * hdr.scl_slope) + hdr.scl_inter;
		} else {
			hdr.scl_slope = 1.0;
			hdr.scl_inter = 0.0;
		}
		//console.log("vx %d type %d mn %f mx %f", vox, hdr.datatypeCode, mn, mx);
		//console.log("cal mn..mx %f..%f", hdr.cal_min, hdr.cal_max);
		hdr.global_min = mn;
		hdr.global_max = mx;
		if ((!isFinite(hdr.cal_min)) || (!isFinite(hdr.cal_max)) || (hdr.cal_min >= hdr.cal_max)) {
			hdr.cal_min = mn;
			hdr.cal_max = mx;
		}
		updateVolume();
	});
} // selectVolume()

function textureFromPixelArray(gl, dataArray, type, width, height) {
    var dataTypedArray = new Uint8Array(dataArray); // Don't need to do this if the data is already in a typed array
    var texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, type, width, height, 0, type, gl.UNSIGNED_BYTE, dataTypedArray);
    // Other texture setup here, like filter modes and mipmap generation
    return texture;
} // textureFromPixelArray()

function byteBound(flt) { //return range 0..255
	var ret = Math.min(flt, 255);
	return Math.max(ret, 0);
}

//var lut = makeLut([0, 255], [0, 255], [0,255], [0,128],[0,255]); //gray
function makeLut(Rs, Gs, Bs, As, Is) {
//create color lookup table provided arrays of reds, greens, blues, alphas and intensity indices
//intensity indices should be in increasing order with the first value 0 and the last 255.
// makeLut([0, 255], [0, 0], [0,0], [0,128],[0,255]); //red gradient
	var lut = new Uint8Array(256 * 4);
	for (i = 0; i < (Is.length-1); i++) {
		//return a + f * (b - a);
		var idxLo = Is[i];
		var idxHi = Is[i+1];
		var idxRng = idxHi - idxLo;
		var k = idxLo * 4;
		for (j = idxLo; j <= idxHi; j++) {
			var f = (j-idxLo)/idxRng;
			lut[k] = byteBound(Rs[i] + f * (Rs[i+1]- Rs[i])); //Red
			k++;
			lut[k] = byteBound(Gs[i] + f * (Gs[i+1]- Gs[i])); //Green
			k++;
			lut[k] = byteBound(Bs[i] + f * (Bs[i+1]- Bs[i])); //Blue
			k++;
			lut[k] = byteBound(As[i] + f * (As[i+1]- As[i])); //Alpha
			k++;
		}
	}
    return lut;
} // makeLut()

window.onload = function(){
	//menu items
	var buttons = document.getElementsByClassName("viewBtn");
	for (let i = 0; i < buttons.length; i++)
		buttons[i].addEventListener("click", onButtonClick, false);
	buttons = document.getElementsByClassName("divider");
	for (let i = 0; i < buttons.length; i++)
		buttons[i].addEventListener("click", onButtonClick, false);
	gl = canvas.getContext("webgl2");
	if (!gl) {
		alert("Unable to initialize WebGL2. Your browser may not support it");
		return;
	}
	window.addEventListener('resize', onWindowResize, false);
	onWindowResize(true);
	// Register mouse and touch listeners
	var controller = new Controller();
	controller.mousemove = function(prev, cur, evt) {
		if (evt.buttons == 1) {
			camera.rotate(prev, cur);

		} else if (evt.buttons == 2) {
			camera.pan([cur[0] - prev[0], prev[1] - cur[1]]);
		}
	};
	controller.wheel = function(amt) { camera.zoom(amt); };
	controller.pinch = controller.wheel;
	controller.twoFingerDrag = function(drag) { camera.pan(drag); };
	controller.registerForCanvas(canvas);
	// Setup VAO and VBO to render the cube to run the raymarching shader
	vao = gl.createVertexArray();
	gl.bindVertexArray(vao);
	vbo = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cubeStrip), gl.STATIC_DRAW);
	gl.enableVertexAttribArray(0);
	gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);
	//sliceShader handles 2D slices: axial, coronal, sagittal
	sliceShader = new Shader(vertSliceShader, fragSliceShader);
	sliceShader.use();
	//line shader draws cross-hairs
	lineShader = new Shader(vertLineShader, fragLineShader); 
	lineShader.use();
	sobelShader = new Shader(blurVertShader, sobelFragShader);
	sobelShader.use();
	blurShader = new Shader(blurVertShader, blurFragShader);
	blurShader.use();
	setShader(5); //Matcap shader
	// Setup required OpenGL state for drawing the back faces and
	// composting with the background color
	gl.enable(gl.CULL_FACE);
	gl.cullFace(gl.FRONT);
	gl.enable(gl.BLEND);
	gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
	//gl.clearColor(1, 0.5, 0.5, 3);
	// Load the default colormap and upload it, after which we
	// load the default volume.
	selectJpeg('0.jpg')
	selectColormap("Gray");
	//selectVolume("spmSmall.nii.gz");
	selectVolume("spm152.nii.gz");
} // window.onload()

function setShader(shaderInt) { //0=default, 1=lighting, 2=Maximum Intensity
	is2D = false;
	if (shaderInt >= 5) {
		//shader = new Shader(vertShader2D, fragShader2D);
		sliceShader.use();
		gl.uniform1i(sliceShader.uniforms["volume"], 0);
		gl.uniform1i(sliceShader.uniforms["colormap"], 1);
		is2D = true;
	}
	if (shaderInt === 4)
		shader = new Shader(vertShader, fragShaderMatCap);
	else if (shaderInt === 3)
		shader = new Shader(vertShader, fragShaderGradients);
	else if (shaderInt === 2)
		shader = new Shader(vertShader, fragShaderMIP);
	else if (shaderInt === 1)
		shader = new Shader(vertShader, fragShaderLighting);
	else
		shader = new Shader(vertShader, fragShader);
	shader.use();
	gl.uniform1i(shader.uniforms["volume"], 0);
	gl.uniform1i(shader.uniforms["colormap"], 1);
	gl.uniform1i(shader.uniforms["gradients"], 2);
	gl.uniform1i(shader.uniforms["matcap"], 3); //matcapTexture
	gl.uniform1f(shader.uniforms["dt_scale"], 1.0);
} // setShader()

function onWindowResize(isInit = false) {
	WIDTH = canvas.clientWidth;
  	HEIGHT = canvas.clientHeight;//menuHeight;
 	// Check if the canvas is not the same size.
  	if (canvas.width  != WIDTH || canvas.height != HEIGHT) {
    	// Make the canvas the same size
    	canvas.width  = WIDTH;
    	canvas.height = HEIGHT;
    	//console.log("<< %s  %s", WIDTH, HEIGHT);
  	}
	//https://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
	gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
	proj = mat4.perspective(mat4.create(), 15 * Math.PI / 180.0,WIDTH / HEIGHT, 0.1, 100);
	camera = new ArcballCamera(center, 2, [WIDTH, HEIGHT]);
	projView = mat4.create();
	const kRot = Math.sqrt(0.5);
    camera.rotateY([0.0,kRot]);
    camera.rotateY([kRot,0.0]);
	//if (isInit) return;
	//samplingRate = 1.0;
	//gl.uniform1f(shader.uniforms["dt_scale"], samplingRate);
	if ((shader !==null) && (isDrawOnDemand)) glDraw();
} // onWindowResize()

function onButtonClick(event) {
	var el = this.parentNode;
	el.style.display = "none";
	setTimeout(function() { //close menu
		el.style.removeProperty("display");
	}, 500);
	if (event.target.id === "ChangeContrast") {
		str = prompt("Set display intensity minimum and maximum", hdr.cal_min.toString()+" "+hdr.cal_max.toString() );
		//if (isNaN(n))
		//	return;
		var strs = str.split(" ");
		if (strs.length < 2) return;
		hdr.cal_min = +strs[0];
		hdr.cal_max = +strs[1];
		updateVolume();
		return;
	}
	if (event.target.id === "SaveBitmap") {
		takeScreenShot = true;
		if (isDrawOnDemand) glDraw();
		return;
	}
	if(event.target.id.charAt(0) === '^') { //shader
		s = event.target.id.substr(1);
		console.log("Setting shader to "+ s);
		if (s === "Lighting")
			setShader(1);
		else if (s === "MIP")
			setShader(2);
		else if (s === "Gradients")
			setShader(3);
		else if (s === "MatCap")
			setShader(4);
		else if (s === "Slices")
			setShader(5);
		else
			setShader(0);
        updateVolume();
		//this.toggleClass('dropdown-item-checked');
		if (isDrawOnDemand) glDraw();
		return;
	}
	if(event.target.id.charAt(0) === '!') { //load color scheme
		s = event.target.id.substr(1);
		colorOpacity = 2.0;
		selectColormap(s);
		if (isDrawOnDemand) glDraw();
		return;
	}
	if(event.target.id.charAt(0) === '#') { //load color scheme
		s = event.target.id.substr(1)+'.jpg';
		colorOpacity = 2.0;
		selectJpeg(s);
		if (isDrawOnDemand) glDraw();
		return;
	}

	if(event.target.id.charAt(0) === '_') { //load NIfTI volume
		s = event.target.id.substr(1);
		selectVolume(s);
		return;
	}
	if (event.target.id === "Open") {
		openDialog.click();
		return;
	}
	if (event.target.id === "About") {
		alert("MRIcroGL for Web by Chris Rorden. Using Will Usher's Volume Raycaster");
		return;
	}
	if (event.target.id === "OpacityInc") {
		adjustOpacity(1.2);
		return;
	}
	if (event.target.id === "OpacityDec") {
		adjustOpacity(0.8);
		return;
	}
	if (event.target.id === "BackColor") {
		if (isBlackBackColor)
			document.body.style.background = "#FFFFFF";
		else
			document.body.style.background = "#000000";
		isBlackBackColor = !isBlackBackColor;
		return;
	}
	const kRot = Math.sqrt(0.5);
	if (event.target.id === "R") {
		camera = new ArcballCamera(center, 2, [WIDTH, HEIGHT]);
		camera.rotateY([0.0,kRot]);
		camera.rotateY([-kRot,0.0]);
		if (isDrawOnDemand) glDraw();
		return;
	}
	if (event.target.id === "L") {
		camera = new ArcballCamera(center, 2, [WIDTH, HEIGHT]);
		camera.rotateY([0.0,kRot]);
		camera.rotateY([kRot,0.0]);
		if (isDrawOnDemand) glDraw();
		return;
	}
	if (event.target.id === "A") {
		camera = new ArcballCamera(center, 2, [WIDTH, HEIGHT]);
		camera.rotateY([0.0,kRot]);
		camera.rotateY([kRot*2,0.0]);
		if (isDrawOnDemand) glDraw();
		return;
	}
	if (event.target.id === "P") {
		camera = new ArcballCamera(center, 2, [WIDTH, HEIGHT]);
		camera.rotateY([0.0,kRot]);
		if (isDrawOnDemand) glDraw();
		return;
	}
	if (event.target.id === "I") {
		camera = new ArcballCamera(center, 2, [WIDTH, HEIGHT]);
		camera.rotateY([-2*kRot,0]);
		if (isDrawOnDemand) glDraw();
		return;
	}
	if (event.target.id === "S") {
		camera = new ArcballCamera(center, 2, [WIDTH, HEIGHT]);
		if (isDrawOnDemand) glDraw();
		return;
	}
	console.log('Unknown menu item ', event.target.id);
} // onButtonClick()

function allowDrop(ev) {
  ev.preventDefault();
} // allowDrop()

function drag(ev) {
  ev.dataTransfer.setData("text", ev.target.id);
}

function drop(ev) {
  ev.preventDefault();
  console.log(ev.dataTransfer.files[0])
  selectVolume(ev.dataTransfer.files[0], false);
} // drag()

</script>
</html>